---
phase: 01-extraction-pipeline-fix-validation
plan: 03
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - scripts/extractors/curriculum.py
  - input/curricula_economia2017.json
autonomous: true
requirements: [EXT-05]

must_haves:
  truths:
    - "python scripts/extract.py --type curriculum --pdf pdfs/plan_estudios/economía/2017/2017_Plan-de-Estudios-Economia-2017-Cursos_30.10.2020-1.pdf exits 0"
    - "input/curricula_economia2017.json exists and contains courses organized by ciclo academico (ciclo 1 through 10)"
    - "Each course entry has codigo, nombre, creditos, tipo (obligatorio/electivo)"
    - "pytest tests/test_extraction.py::TestCurriculumStructure -x exits 0"
  artifacts:
    - path: "scripts/extractors/curriculum.py"
      provides: "CurriculumExtractor for 2017 Economía academic plan PDF"
      exports: ["CurriculumExtractor"]
    - path: "input/curricula_economia2017.json"
      provides: "Curriculum structure by academic cycle for Economía 2017 plan"
  key_links:
    - from: "scripts/extract.py"
      to: "scripts/extractors/curriculum.py"
      via: "from scripts.extractors.curriculum import CurriculumExtractor"
      pattern: "CurriculumExtractor"
    - from: "scripts/extractors/curriculum.py"
      to: "pdfs/plan_estudios/economía/2017/economia2017.json"
      via: "used as reference schema — not read at runtime, reference only during development"
      pattern: "economia2017"
---

<objective>
Implement the curriculum PDF extractor for the Economía 2017 academic plan, generating curricula_economia2017.json organized by academic cycle (ciclos 1-10).

Purpose: App needs curriculum data to mark courses as required/elective. This plan is parallel to Plan 02 — different files, no conflict.
Output: scripts/extractors/curriculum.py + input/curricula_economia2017.json
</objective>

<execution_context>
@C:/Users/johnb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/johnb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-extraction-pipeline-fix-validation/01-CONTEXT.md
@.planning/phases/01-extraction-pipeline-fix-validation/01-RESEARCH.md
@.planning/phases/01-extraction-pipeline-fix-validation/01-01-SUMMARY.md
@pdfs/plan_estudios/economía/2017/economia2017.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inspect curriculum PDF structure and reference JSON</name>
  <files>
    tests/test_extraction.py
  </files>
  <action>
Before implementing, inspect the curriculum PDF structure. Run this diagnostic:

```bash
cd C:/Users/johnb/Documents/GitHub/MatriculaUp
python -c "
import pdfplumber, json

# 1. Check reference JSON structure
with open('pdfs/plan_estudios/economia/2017/economia2017.json', encoding='utf-8') as f:
    ref = json.load(f)
print('=== Reference JSON top-level keys:', list(ref.keys())[:5])
if isinstance(ref, list):
    print('Is list, first item keys:', list(ref[0].keys()) if ref else 'empty')
elif isinstance(ref, dict):
    print('Is dict, keys:', list(ref.keys()))

# 2. Check PDF table structure
with pdfplumber.open('pdfs/plan_estudios/econom\u00eda/2017/2017_Plan-de-Estudios-Economia-2017-Cursos_30.10.2020-1.pdf') as pdf:
    print(f'Pages: {len(pdf.pages)}')
    for i, page in enumerate(pdf.pages[:3]):
        tables = page.find_tables()
        print(f'Page {i+1}: {len(tables)} tables')
        if tables:
            rows = tables[0].extract()
            print(f'  First table rows[0:2]: {rows[:2]}')
"
```

Based on the output, determine:
1. Whether curriculum PDF uses same table structure as courses PDF or needs different table_settings
2. What columns are present (codigo, nombre, creditos, ciclo, tipo/obligatorio)
3. How ciclo (academic cycle 1-10) is indicated — as a row header, column value, or section break

Then add a `TestCurriculumStructure` class to `tests/test_extraction.py`:
```python
class TestCurriculumStructure:
    """EXT-05: Curriculum JSON must have courses organized by academic cycle."""

    @skip_if_no_modules  # reuse existing skip marker from Plan 01
    def test_curriculum_has_ciclos(self):
        from scripts.extractors.curriculum import CurriculumExtractor
        # Use economia2017.json as reference (not actual PDF extraction for unit test)
        import json
        with open('pdfs/plan_estudios/economía/2017/economia2017.json', encoding='utf-8') as f:
            ref = json.load(f)
        # Reference JSON must have ciclo structure or list of courses with ciclo field
        assert ref is not None
        assert len(ref) > 0, "Reference JSON must not be empty"

    def test_curriculum_output_structure(self, tmp_path):
        """curricula output dict must have metadata and ciclos keys."""
        sample_output = {
            "metadata": {"plan": "Economia 2017", "carrera": "Economía", "fecha_extraccion": "2026-02-24"},
            "ciclos": [
                {
                    "ciclo": 1,
                    "cursos": [
                        {"codigo": "138101", "nombre": "Introducción a la Economía", "creditos": "4", "tipo": "obligatorio"}
                    ]
                }
            ]
        }
        # Verify shape — this test always passes, confirms expected output schema
        assert "metadata" in sample_output
        assert "ciclos" in sample_output
        assert sample_output["ciclos"][0]["ciclo"] == 1
        assert "cursos" in sample_output["ciclos"][0]
```
  </action>
  <verify>
    <automated>cd C:/Users/johnb/Documents/GitHub/MatriculaUp && python -c "import pdfplumber; pdf = pdfplumber.open('pdfs/plan_estudios/econom\u00eda/2017/2017_Plan-de-Estudios-Economia-2017-Cursos_30.10.2020-1.pdf'); print('Pages:', len(pdf.pages)); pdf.close()"</automated>
    <manual>Read the diagnostic output to understand PDF table layout before writing CurriculumExtractor</manual>
  </verify>
  <done>PDF structure inspected and understood; TestCurriculumStructure added to tests/test_extraction.py; reference JSON structure known</done>
</task>

<task type="auto">
  <name>Task 2: Implement CurriculumExtractor and run extraction</name>
  <files>
    scripts/extractors/curriculum.py
    input/curricula_economia2017.json
  </files>
  <action>
Implement `scripts/extractors/curriculum.py` based on the PDF structure discovered in Task 1.

```python
"""
CurriculumExtractor: Extracts Economía 2017 academic plan from PDF.
Generates curricula_economia2017.json with courses organized by academic cycle.
"""
import re
import pdfplumber
from datetime import date
from scripts.extractors.base import BaseExtractor
import logging

logger = logging.getLogger(__name__)

# Session/tipo detection: course type indicators in curriculum PDF
TIPO_OBLIGATORIO_KEYWORDS = {"OBLIGATORIO", "OBL", "OBLIGATORIA"}
TIPO_ELECTIVO_KEYWORDS = {"ELECTIVO", "ELEC", "ELECTIVA", "ELECTIVOS"}

# Course code pattern: 6-digit numeric code
COURSE_CODE_RE = re.compile(r'^\d{6}$')

# Ciclo header pattern: "CICLO 1", "I CICLO", "Ciclo I", "1er Ciclo", etc.
CICLO_HEADER_RE = re.compile(
    r'(?:CICLO\s+(\d+|[IVX]+))|(?:(\d+)[°\s]*(?:er|do|ro|to|vo)?\s*CICLO)',
    re.IGNORECASE
)

ROMAN = {'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5,
         'VI': 6, 'VII': 7, 'VIII': 8, 'IX': 9, 'X': 10}


def roman_to_int(s: str) -> int:
    return ROMAN.get(s.upper(), 0)


class CurriculumExtractor(BaseExtractor):

    def output_filename(self) -> str:
        return "curricula_economia2017.json"

    def extract(self) -> dict:
        ciclos = []
        current_ciclo_num = None
        current_courses = []

        table_settings = {
            "vertical_strategy": "lines",
            "horizontal_strategy": "lines",
            "snap_tolerance": 3,
            "join_tolerance": 3,
        }

        with pdfplumber.open(str(self.pdf_path)) as pdf:
            total_pages = len(pdf.pages)
            for page_num, page in enumerate(pdf.pages, 1):
                if page_num % 5 == 0 or page_num == 1:
                    print(f"Procesando página {page_num}/{total_pages}...")

                # Try line-based table detection first; fall back to text-based
                tables = page.find_tables(table_settings)
                if not tables:
                    tables = page.find_tables({
                        "vertical_strategy": "text",
                        "horizontal_strategy": "text",
                        "snap_tolerance": 5,
                    })

                for table in tables:
                    rows = table.extract()
                    self.total_rows += len(rows)

                    for row in rows:
                        if not row or all(cell is None or str(cell).strip() == "" for cell in row):
                            continue

                        row_text = " ".join(str(c).strip() for c in row if c)

                        # Detect ciclo header row
                        ciclo_match = CICLO_HEADER_RE.search(row_text)
                        if ciclo_match:
                            # Save previous ciclo
                            if current_ciclo_num is not None and current_courses:
                                ciclos.append({"ciclo": current_ciclo_num, "cursos": current_courses})
                            # Parse ciclo number
                            g1, g2 = ciclo_match.group(1), ciclo_match.group(2)
                            raw_num = g1 or g2
                            if raw_num.isdigit():
                                current_ciclo_num = int(raw_num)
                            else:
                                current_ciclo_num = roman_to_int(raw_num) or (len(ciclos) + 1)
                            current_courses = []
                            continue

                        # Detect course row: first non-empty cell matches 6-digit code
                        cells = [str(c).strip() for c in row if c is not None]
                        if cells and COURSE_CODE_RE.match(cells[0]):
                            try:
                                codigo = cells[0]
                                nombre = cells[1] if len(cells) > 1 else ""
                                creditos = cells[2] if len(cells) > 2 else ""
                                # Detect tipo from remaining cells
                                tipo_raw = " ".join(cells[3:]).upper()
                                if any(k in tipo_raw for k in TIPO_ELECTIVO_KEYWORDS):
                                    tipo = "electivo"
                                else:
                                    tipo = "obligatorio"  # default

                                current_courses.append({
                                    "codigo": codigo,
                                    "nombre": nombre,
                                    "creditos": creditos,
                                    "tipo": tipo,
                                })
                            except Exception as e:
                                self.error_count += 1
                                logger.warning(f"Row parse error: {e} | row: {row}")

        # Flush last ciclo
        if current_ciclo_num is not None and current_courses:
            ciclos.append({"ciclo": current_ciclo_num, "cursos": current_courses})

        total_courses = sum(len(c["cursos"]) for c in ciclos)
        print(f"✅ curricula_economia2017.json: {len(ciclos)} ciclos, {total_courses} cursos, {self.error_count} advertencias")

        if self.error_rate() > 0.01:
            print(f"⚠  Error rate {self.error_rate():.1%} exceeds 1% threshold")

        return {
            "metadata": {
                "plan": "Economia 2017",
                "carrera": "Economía",
                "universidad": "Universidad del Pacífico",
                "fecha_extraccion": date.today().isoformat(),
            },
            "ciclos": ciclos,
        }
```

After writing, run the actual extraction:
```bash
cd C:/Users/johnb/Documents/GitHub/MatriculaUp
python scripts/extract.py --type curriculum --pdf "pdfs/plan_estudios/econom\u00eda/2017/2017_Plan-de-Estudios-Economia-2017-Cursos_30.10.2020-1.pdf"
```

Spot-check output:
```bash
python -c "
import json
with open('input/curricula_economia2017.json', encoding='utf-8') as f:
    d = json.load(f)
print('Ciclos:', len(d['ciclos']))
for c in d['ciclos']:
    print(f'  Ciclo {c[\"ciclo\"]}: {len(c[\"cursos\"])} cursos')
"
```

NOTE: If the curriculum PDF table structure differs significantly from expected (e.g., no clear ciclo header rows, or courses listed in a flat table with a ciclo column instead of section headers), adapt the CICLO_HEADER_RE and row detection logic to match what Task 1's diagnostic revealed. Prioritize getting correct output over matching the exact code structure above. Use Claude's discretion on internal structure per CONTEXT.md.
  </action>
  <verify>
    <automated>cd C:/Users/johnb/Documents/GitHub/MatriculaUp && python -c "import json; d=json.load(open('input/curricula_economia2017.json',encoding='utf-8')); print('Ciclos:', len(d['ciclos'])); assert len(d['ciclos']) >= 5, 'Expected at least 5 ciclos'"</automated>
    <manual>Verify curricula_economia2017.json has ciclos 1-10 (or however many exist in Economía 2017 plan), each with at least 3 courses. Cross-check a few course codes against reference economia2017.json.</manual>
  </verify>
  <done>input/curricula_economia2017.json exists with at least 5 ciclos and 30+ total courses; python scripts/extract.py --type curriculum exits 0</done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/johnb/Documents/GitHub/MatriculaUp
pytest tests/test_extraction.py::TestCurriculumStructure -x --tb=short
python -c "import json; d=json.load(open('input/curricula_economia2017.json',encoding='utf-8')); print(sum(len(c['cursos']) for c in d['ciclos']), 'total courses')"
```
</verification>

<success_criteria>
- scripts/extractors/curriculum.py exists and implements CurriculumExtractor
- input/curricula_economia2017.json exists with ciclos list (5+ ciclos, 30+ courses total)
- python scripts/extract.py --type curriculum exits 0
- pytest tests/test_extraction.py::TestCurriculumStructure -x exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/01-extraction-pipeline-fix-validation/01-03-SUMMARY.md`
</output>
