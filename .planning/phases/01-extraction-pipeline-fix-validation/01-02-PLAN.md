---
phase: 01-extraction-pipeline-fix-validation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - scripts/extract.py
  - scripts/extractors/__init__.py
  - scripts/extractors/base.py
  - scripts/extractors/courses.py
autonomous: true
requirements: [EXT-01, EXT-02, EXT-03]

must_haves:
  truths:
    - "python scripts/extract.py --type courses --pdf pdfs/matricula/2026-1/regular/Oferta-Academica-2026-I_v1.pdf exits 0 and writes input/courses_2026-1.json"
    - "courses_2026-1.json contains at least 50 courses each with codigo, nombre, creditos, secciones"
    - "No prerequisite in courses_2026-1.json ends with 'Y (' or 'O (' (truncation bug fixed)"
    - "Professor names with 'Del', 'De La', 'De Los' are captured in full (not truncated at preposition)"
    - "pytest tests/test_extraction.py -x exits 0 (all tests GREEN)"
  artifacts:
    - path: "scripts/extractors/courses.py"
      provides: "CourseOfferingExtractor — table extraction, prerequisite buffer, Spanish name regex"
      exports: ["extract_prerequisites_with_continuation", "extract_professors_spanish", "is_truncated_prerequisite"]
    - path: "scripts/extract.py"
      provides: "CLI entry point accepting --type courses --pdf <path>"
    - path: "input/courses_2026-1.json"
      provides: "Extracted courses data for 2026-1 academic offer"
  key_links:
    - from: "scripts/extract.py"
      to: "scripts/extractors/courses.py"
      via: "CourseOfferingExtractor import and instantiation"
      pattern: "from scripts.extractors.courses import"
    - from: "scripts/extractors/courses.py"
      to: "pdfplumber"
      via: "pdfplumber.open() + page.extract_tables()"
      pattern: "pdfplumber\\.open"
    - from: "scripts/extractors/courses.py"
      to: "input/courses_2026-1.json"
      via: "json.dump with encoding='utf-8'"
      pattern: "json\\.dump"
---

<objective>
Implement the courses PDF extractor: migrate v6 notebook logic to scripts/extractors/courses.py, fixing prerequisite multi-row truncation (EXT-02) and Spanish compound surname regex (EXT-03), and wire the CLI entry point (EXT-01).

Purpose: Core extraction bug fixes that make courses_2026-1.json trustworthy for app development.
Output: scripts/extract.py CLI + scripts/extractors/courses.py + input/courses_2026-1.json
</objective>

<execution_context>
@C:/Users/johnb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/johnb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-extraction-pipeline-fix-validation/01-CONTEXT.md
@.planning/phases/01-extraction-pipeline-fix-validation/01-RESEARCH.md
@.planning/phases/01-extraction-pipeline-fix-validation/01-01-SUMMARY.md
@scripts/pdf_to_csv.ipynb
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement courses extractor with bug fixes</name>
  <files>
    scripts/extractors/__init__.py
    scripts/extractors/base.py
    scripts/extractors/courses.py
  </files>
  <action>
Read scripts/pdf_to_csv.ipynb first to understand v6 extraction logic before writing new code.

`scripts/extractors/__init__.py` — empty init file.

`scripts/extractors/base.py` — abstract base class:
```python
from abc import ABC, abstractmethod
from pathlib import Path
import json
import logging

logger = logging.getLogger(__name__)

class BaseExtractor(ABC):
    def __init__(self, pdf_path: str, output_dir: str = "input"):
        self.pdf_path = Path(pdf_path)
        self.output_dir = Path(output_dir)
        self.warnings = []
        self.error_count = 0
        self.total_rows = 0

    @abstractmethod
    def extract(self) -> dict:
        pass

    @abstractmethod
    def output_filename(self) -> str:
        pass

    def save(self, data: dict) -> Path:
        self.output_dir.mkdir(exist_ok=True)
        out = self.output_dir / self.output_filename()
        with open(out, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return out

    def error_rate(self) -> float:
        if self.total_rows == 0:
            return 0.0
        return self.error_count / self.total_rows
```

`scripts/extractors/courses.py` — implement with these specific requirements:

1. **`is_truncated_prerequisite(text: str) -> bool`**: Return True if text stripped ends with any of: `"Y ("`, `"O ("`, `"Y"`, `"O"`, `"("`. Use `text.rstrip()`.

2. **`extract_professors_spanish(text: str) -> list[str]`**: Split text on ` / ` separator first (multiple professors), then for each part apply regex that accepts lowercase Spanish prepositions mid-firstname:
   ```python
   # Pattern accepts: LASTNAME, Firstname [de/del/de la/de los] [Suffix]
   PROF_PATTERN = re.compile(
       r'([A-ZÑÁÉÍÓÚ][A-ZÁÉÍÓÚÑ\s]+,\s+'
       r'[A-ZÁÉÍÓÚÑ][A-Za-záéíóúñÁÉÍÓÚÑ]+'
       r'(?:\s+(?:[Dd]e(?:\s+[Ll]a(?:\s+[A-ZÁÉÍÓÚÑ][A-Za-záéíóúñ]+)?)?|[Dd]el|[Dd]e\s+[Ll]os|[Ll]a|[Yy])'
       r'(?:\s+[A-ZÁÉÍÓÚÑ][A-Za-záéíóúñÁÉÍÓÚÑ\s]*)?)*)'
   )
   ```
   If regex doesn't match (edge case), return the stripped text as a single-element list — never discard a name.

3. **`extract_prerequisites_with_continuation(rows: list) -> list[dict]`**: Continuation buffer algorithm:
   - Detect new course by matching 6-digit code at start of first non-empty cell: `re.match(r'^\d{6}', cell)`
   - When a new course is detected: flush buffer into current course's prerequisitos field, then start new course
   - Continuation row: first cell is empty/whitespace → append to buffer
   - Section/class row: contains CLASE/PRÁCTICA/etc. in any cell → flush buffer and start session parsing
   - After all rows: flush final buffer
   - For each merged prerequisite string: call `is_truncated_prerequisite()`. If truncated, store as `{"raw": text, "parsed": False}` and log warning. If clean, attempt `parse_prerequisite_tree(text)` (see below).

4. **`parse_prerequisite_tree(text: str) -> dict`**: Attempt to build `{"op": "AND"|"OR", "items": [...]}` tree. If text is a single course code + name (no Y/O logic), return `{"items": [{"code": code, "name": name}]}`. If parsing fails at any point, return `{"raw": text, "parsed": False}`. Never raise — always return something.

5. **`class CourseOfferingExtractor(BaseExtractor)`**: Full implementation:
   - `output_filename()`: Return `f"courses_{self.cycle}.json"` where cycle is parsed from PDF filename (regex `r'(\d{4}-[12I])'`) or defaults to "2026-1"
   - `extract()`: Open PDF with pdfplumber. For each page, call `page.find_tables(table_settings)` with `table_settings = {"vertical_strategy": "lines", "horizontal_strategy": "lines", "snap_tolerance": 3, "join_tolerance": 3}`. If no tables found on page (cover/header pages), skip silently.
   - Process each table with `extract_prerequisites_with_continuation()`.
   - After extraction, compute error_rate(). If > 0.01, print warning with `⚠️  Error rate {rate:.1%} exceeds 1% threshold`.
   - Print summary: `✅ courses.json: {N} cursos, {M} secciones promedio, {K} advertencias`
   - Return dict: `{"metadata": {"ciclo": cycle, "fecha_extraccion": date.today().isoformat()}, "cursos": [...]}`

All file I/O: use `encoding='utf-8'`. All print statements for progress: `Procesando página {n}/{total}...` every 10 pages.
  </action>
  <verify>
    <automated>cd C:/Users/johnb/Documents/GitHub/MatriculaUp && pytest tests/test_extraction.py -x --tb=short -q</automated>
    <manual>Check that test_professor_spanish_names and test_prerequisite_continuation tests are GREEN (not skipped)</manual>
  </verify>
  <done>pytest tests/test_extraction.py -x exits 0; all TestPrerequisiteContinuation and TestProfessorSpanishNames tests pass GREEN</done>
</task>

<task type="auto">
  <name>Task 2: Wire CLI entry point and run extraction</name>
  <files>
    scripts/extract.py
    input/courses_2026-1.json
  </files>
  <action>
Create `scripts/extract.py` as the single CLI entry point that replaces pdf_to_csv.ipynb.

```python
#!/usr/bin/env python3
"""
MatriculaUp PDF Extractor
Usage:
  python scripts/extract.py --type courses --pdf <path>
  python scripts/extract.py --type curriculum --pdf <path>
"""
import argparse
import sys
from pathlib import Path

# Add project root to path so 'scripts.extractors' imports work
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.extractors.courses import CourseOfferingExtractor


def main():
    parser = argparse.ArgumentParser(description="MatriculaUp PDF Extractor")
    parser.add_argument("--type", required=True, choices=["courses", "curriculum"],
                        help="Type of PDF to extract")
    parser.add_argument("--pdf", required=True, help="Path to PDF file")
    parser.add_argument("--output-dir", default="input", help="Output directory (default: input/)")
    args = parser.parse_args()

    pdf_path = Path(args.pdf)
    if not pdf_path.exists():
        print(f"✗ PDF not found: {pdf_path}", file=sys.stderr)
        sys.exit(1)

    if args.type == "courses":
        extractor = CourseOfferingExtractor(str(pdf_path), args.output_dir)
    elif args.type == "curriculum":
        # Plan 03 implements CurriculumExtractor — import lazily to avoid import error
        try:
            from scripts.extractors.curriculum import CurriculumExtractor
            extractor = CurriculumExtractor(str(pdf_path), args.output_dir)
        except ImportError:
            print("✗ Curriculum extractor not yet implemented", file=sys.stderr)
            sys.exit(1)

    data = extractor.extract()
    out_path = extractor.save(data)
    print(f"✓ Output written to {out_path}")

    if extractor.error_rate() > 0.01:
        print(f"⚠  Error rate {extractor.error_rate():.1%} exceeds threshold", file=sys.stderr)
        sys.exit(1)

    sys.exit(0)


if __name__ == "__main__":
    main()
```

After writing, run the actual extraction:
```bash
cd C:/Users/johnb/Documents/GitHub/MatriculaUp
python scripts/extract.py --type courses --pdf "pdfs/matricula/2026-1/regular/Oferta-Academica-2026-I_v1.pdf"
```

If it exits 0, verify input/courses_2026-1.json was created and spot-check:
```bash
python -c "
import json
with open('input/courses_2026-1.json', encoding='utf-8') as f:
    data = json.load(f)
courses = data['cursos']
print(f'Cursos: {len(courses)}')
# Spot-check: no truncated prerequisites
truncated = [c for c in courses if isinstance(c.get('prerequisitos'), str) and c['prerequisitos'].rstrip().endswith(('Y (', 'O ('))]
print(f'Truncated prereqs: {len(truncated)}')
# Spot-check: find a compound surname
from scripts.extractors.courses import extract_professors_spanish
all_profs = set()
for c in courses:
    for s in c.get('secciones', []):
        all_profs.update(s.get('docentes', []))
compound = [p for p in all_profs if any(x in p for x in ['Del ', 'De La ', 'De Los '])]
print(f'Compound surname professors found: {len(compound)}')
if compound:
    print('Examples:', compound[:3])
"
```
  </action>
  <verify>
    <automated>cd C:/Users/johnb/Documents/GitHub/MatriculaUp && python -c "import json; d=json.load(open('input/courses_2026-1.json',encoding='utf-8')); print(f'OK: {len(d[\"cursos\"])} cursos')"</automated>
    <manual>Open input/courses_2026-1.json and verify: (1) at least 50 courses present, (2) secciones and sesiones nested correctly, (3) no prerequisito ends with "Y (" or "O ("</manual>
  </verify>
  <done>input/courses_2026-1.json exists, loads without error, contains 50+ courses; python scripts/extract.py --type courses exits 0; pytest tests/test_extraction.py -x exits 0</done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/johnb/Documents/GitHub/MatriculaUp
pytest tests/test_extraction.py -x --tb=short -q
python -c "import json; d=json.load(open('input/courses_2026-1.json',encoding='utf-8')); print(len(d['cursos']), 'cursos')"
```
Both must succeed.
</verification>

<success_criteria>
- scripts/extractors/courses.py exists and exports is_truncated_prerequisite, extract_professors_spanish, CourseOfferingExtractor
- scripts/extract.py --type courses runs and exits 0
- input/courses_2026-1.json exists with 50+ courses
- pytest tests/test_extraction.py -x exits 0 (all tests GREEN)
- No truncated prerequisites in output (validated by spot-check script above)
</success_criteria>

<output>
After completion, create `.planning/phases/01-extraction-pipeline-fix-validation/01-02-SUMMARY.md`
</output>
